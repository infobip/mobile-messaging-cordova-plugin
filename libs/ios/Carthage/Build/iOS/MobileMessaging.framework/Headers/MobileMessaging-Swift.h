// Generated by Apple Swift version 4.2 (swiftlang-1000.11.37.1 clang-1000.11.45.1)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import CoreData;
@import CoreGraphics;
@import CoreLocation;
@import Dispatch;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="MobileMessaging",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class UIImage;
@class CALayer;
@class NSCoder;

/// <code>AnimatedImageView</code> is a subclass of <code>UIImageView</code> for displaying animated image.
SWIFT_CLASS("_TtC15MobileMessaging17AnimatedImageView")
@interface AnimatedImageView : UIImageView
@property (nonatomic, strong) UIImage * _Nullable image;
@property (nonatomic, readonly, getter=isAnimating) BOOL animating;
/// Starts the animation.
- (void)startAnimating;
/// Stops the animation.
- (void)stopAnimating;
- (void)displayLayer:(CALayer * _Nonnull)layer;
- (void)didMoveToWindow;
- (void)didMoveToSuperview;
- (nonnull instancetype)initWithImage:(UIImage * _Nullable)image OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImage:(UIImage * _Nullable)image highlightedImage:(UIImage * _Nullable)highlightedImage OBJC_DESIGNATED_INITIALIZER SWIFT_AVAILABILITY(ios,introduced=3.0);
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end



enum MessageDirection : int16_t;
enum MessageDeliveryMethod : int16_t;

SWIFT_CLASS("_TtC15MobileMessaging11BaseMessage")
@interface BaseMessage : NSObject
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable customPayload;
@property (nonatomic) enum MessageDirection direction;
@property (nonatomic, copy) NSString * _Nonnull messageId;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull originalPayload;
@property (nonatomic) enum MessageDeliveryMethod deliveryMethod;
@property (nonatomic, copy) NSString * _Nullable text;
@property (nonatomic, readonly) BOOL isChatMessage;
- (nonnull instancetype)initWithMessageId:(NSString * _Nonnull)messageId direction:(enum MessageDirection)direction originalPayload:(NSDictionary<NSString *, id> * _Nonnull)originalPayload deliveryMethod:(enum MessageDeliveryMethod)deliveryMethod OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqualWithObject:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// The subclass of <code>NSOperation</code> from which all other operations should be derived.
/// This class adds both Conditions and Observers, which allow the operation to define
/// extended readiness requirements, as well as notify many interested parties
/// about interesting operation state changes
SWIFT_CLASS("_TtC15MobileMessaging9Operation")
@interface Operation : NSOperation
@property (nonatomic, copy) void (^ _Nullable completionBlock)(void) SWIFT_DEPRECATED_MSG("use BlockObserver completions instead");
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
@property (nonatomic, readonly, getter=isReady) BOOL ready;
@property (nonatomic, readonly, getter=isExecuting) BOOL executing;
@property (nonatomic, readonly, getter=isFinished) BOOL finished;
@property (nonatomic, readonly, getter=isCancelled) BOOL cancelled;
- (void)addDependency:(NSOperation * _Nonnull)operation;
- (void)main;
- (void)cancel;
- (void)waitUntilFinished;
@end


/// A sublcass of <code>Operation</code> to execute a closure.
SWIFT_CLASS("_TtC15MobileMessaging14BlockOperation")
@interface BlockOperation : Operation
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end



@class UIViewController;

/// Default chat view implementation, extends UINavigationController with a CPChatVC put as a root view controller.
SWIFT_CLASS("_TtC15MobileMessaging18CPChatNavigationVC")
@interface CPChatNavigationVC : UINavigationController
- (void)viewWillAppear:(BOOL)animated;
- (void)viewDidLoad;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithNavigationBarClass:(Class _Nullable)navigationBarClass toolbarClass:(Class _Nullable)toolbarClass SWIFT_UNAVAILABLE;
- (nonnull instancetype)initWithRootViewController:(UIViewController * _Nonnull)rootViewController SWIFT_UNAVAILABLE;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end

@class ChatMessagesController;
@class ChatMessage;
enum ChatMessagesChangeType : NSUInteger;

SWIFT_PROTOCOL("_TtP15MobileMessaging30ChatMessagesControllerDelegate_")
@protocol ChatMessagesControllerDelegate
- (void)controllerWillChangeContent:(ChatMessagesController * _Nonnull)controller;
- (void)controller:(ChatMessagesController * _Nonnull)controller didChange:(ChatMessage * _Nonnull)message at:(NSIndexPath * _Nullable)indexPath for:(enum ChatMessagesChangeType)type newIndexPath:(NSIndexPath * _Nullable)newIndexPath;
- (void)controllerDidChangeContent:(ChatMessagesController * _Nonnull)controller;
@end


SWIFT_CLASS("_TtC15MobileMessaging16CPViewController")
@interface CPViewController : UIViewController
- (void)viewWillAppear:(BOOL)animated;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (void)viewDidLoad;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC15MobileMessaging21CPTableViewController")
@interface CPTableViewController : CPViewController
- (void)viewDidLoad;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC15MobileMessaging12CPUserDataVC")
@interface CPUserDataVC : CPTableViewController
- (void)viewDidLoad;
- (void)viewWillAppear:(BOOL)animated;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UIGestureRecognizer;

SWIFT_CLASS("_TtC15MobileMessaging8CPChatVC")
@interface CPChatVC : CPUserDataVC <ChatMessagesControllerDelegate, UIGestureRecognizerDelegate>
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)viewDidLoad;
- (void)viewWillAppear:(BOOL)animated;
- (void)viewDidAppear:(BOOL)animated;
- (void)viewWillDisappear:(BOOL)animated;
- (void)viewDidLayoutSubviews;
- (void)controllerWillChangeContent:(ChatMessagesController * _Nonnull)controller;
- (void)controller:(ChatMessagesController * _Nonnull)controller didChange:(ChatMessage * _Nonnull)message at:(NSIndexPath * _Nullable)indexPath for:(enum ChatMessagesChangeType)type newIndexPath:(NSIndexPath * _Nullable)newIndexPath;
- (void)controllerDidChangeContent:(ChatMessagesController * _Nonnull)controller;
- (BOOL)gestureRecognizer:(UIGestureRecognizer * _Nonnull)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer * _Nonnull)otherGestureRecognizer SWIFT_WARN_UNUSED_RESULT;
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer * _Nonnull)gestureRecognizer SWIFT_WARN_UNUSED_RESULT;
@end





@class UITableView;
@class UITableViewCell;

@interface CPChatVC (SWIFT_EXTENSION(MobileMessaging))
- (NSInteger)tableView:(UITableView * _Nonnull)tableView numberOfRowsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
- (UITableViewCell * _Nonnull)tableView:(UITableView * _Nonnull)tableView cellForRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
@end



@interface CPTableViewController (SWIFT_EXTENSION(MobileMessaging)) <UITableViewDataSource, UITableViewDelegate>
- (NSInteger)tableView:(UITableView * _Nonnull)tableView numberOfRowsInSection:(NSInteger)section SWIFT_WARN_UNUSED_RESULT;
- (UITableViewCell * _Nonnull)tableView:(UITableView * _Nonnull)tableView cellForRowAtIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT;
@end



typedef SWIFT_ENUM(int16_t, CampaignState, closed) {
  CampaignStateActive = 0,
  CampaignStateSuspended = 1,
  CampaignStateFinished = 2,
};


SWIFT_CLASS("_TtC15MobileMessaging11ChatMessage")
@interface ChatMessage : NSObject
@property (nonatomic, readonly) NSUInteger hash;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end





typedef SWIFT_ENUM(NSUInteger, ChatMessagesChangeType, closed) {
  ChatMessagesChangeTypeInsert = 0,
  ChatMessagesChangeTypeDelete = 1,
  ChatMessagesChangeTypeMove = 2,
  ChatMessagesChangeTypeUpdate = 3,
};


/// Controller manages a fetched result controller bound with a private managed object context, it solves all the threading issues for the user, forwarding the fetched result controller delegate callbacks to the main queue. Also hides some internals from the user and simplifies access to messages.
SWIFT_CLASS("_TtC15MobileMessaging22ChatMessagesController")
@interface ChatMessagesController : NSObject <NSFetchedResultsControllerDelegate>
- (void)controllerWillChangeContent:(NSFetchedResultsController<id <NSFetchRequestResult>> * _Nonnull)controller;
- (void)controller:(NSFetchedResultsController<id <NSFetchRequestResult>> * _Nonnull)controller didChangeObject:(id _Nonnull)anObject atIndexPath:(NSIndexPath * _Nullable)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath * _Nullable)newIndexPath;
- (void)controllerDidChangeContent:(NSFetchedResultsController<id <NSFetchRequestResult>> * _Nonnull)controller;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end



SWIFT_CLASS("_TtC15MobileMessaging15ChatParticipant")
@interface ChatParticipant : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging12ChatSettings")
@interface ChatSettings : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_PROTOCOL("_TtP15MobileMessaging27CustomPayloadSupportedTypes_")
@protocol CustomPayloadSupportedTypes
@end

@class NSDate;
@class NSNumber;
@class NSNull;

SWIFT_CLASS("_TtC15MobileMessaging19CustomUserDataValue")
@interface CustomUserDataValue : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable string;
@property (nonatomic, readonly, strong) NSDate * _Nullable date;
@property (nonatomic, readonly, strong) NSNumber * _Nullable number;
- (nonnull instancetype)initWithOptionalLiteral:(id _Nullable)optionalLiteral;
- (nonnull instancetype)initWithNilLiteral;
- (nonnull instancetype)initWithIntegerLiteral:(NSInteger)value;
- (nonnull instancetype)initWithFloatLiteral:(double)value;
- (nonnull instancetype)initWithStringLiteral:(NSString * _Nonnull)value;
- (nonnull instancetype)initWithExtendedGraphemeClusterLiteral:(NSString * _Nonnull)value;
- (nonnull instancetype)initWithUnicodeScalarLiteral:(NSString * _Nonnull)value;
- (nonnull instancetype)initWithDate:(NSDate * _Nonnull)date OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithInteger:(NSInteger)integer OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithDouble:(double)double_ OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithString:(NSString * _Nonnull)string OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithNull:(NSNull * _Nonnull)null OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class DeliveryTimeInterval;

SWIFT_CLASS("_TtC15MobileMessaging12DeliveryTime")
@interface DeliveryTime : NSObject
@property (nonatomic, readonly, strong) DeliveryTimeInterval * _Nullable timeInterval;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging20DeliveryTimeInterval")
@interface DeliveryTimeInterval : NSObject
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class MMRegion;

SWIFT_PROTOCOL("_TtP15MobileMessaging16GeoEventHandling_")
@protocol GeoEventHandling
/// This callback is triggered after the geo event occurs. Default behaviour is implemented by <code>MMDefaultGeoEventHandling</code> class.
- (void)didEnterWithRegion:(MMRegion * _Nonnull)region;
@end

/// Describes the capability status for Geofencing Service. Possible values:
/// <ul>
///   <li>
///     <code>notDetermined</code>: The capability has not been requested yet
///   </li>
///   <li>
///     <code>authorized</code>: The capability has been requested and approved
///   </li>
///   <li>
///     <code>denied</code>: The capability has been requested but was denied by the user
///   </li>
///   <li>
///     <code>notAvailable</code>: The capability is not available (perhaps due to restrictions, or lack of support)
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, GeofencingCapabilityStatus, closed) {
  GeofencingCapabilityStatusNotDetermined = 0,
  GeofencingCapabilityStatusAuthorized = 1,
  GeofencingCapabilityStatusDenied = 2,
  GeofencingCapabilityStatusNotAvailable = 3,
};

@class NSError;
@class CLLocation;
enum LocationServiceUsage : NSInteger;
@class MMGeoMessage;

SWIFT_CLASS("_TtC15MobileMessaging17GeofencingService")
@interface GeofencingService : NSObject
- (void)syncWithServer:(void (^ _Nullable)(NSError * _Nullable))completion;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isGeofencingServiceEnabled;)
+ (BOOL)isGeofencingServiceEnabled SWIFT_WARN_UNUSED_RESULT;
/// Returns current user location with accuracy <code>kCLLocationAccuracyHundredMeters</code>.
@property (nonatomic, readonly, strong) CLLocation * _Nullable currentUserLocation;
/// Returns all the regions available in the Geofencing Service storage.
@property (nonatomic, readonly, copy) NSArray<MMRegion *> * _Nonnull allRegions;
/// Returns current capability status for Geofencing Service. For more information see <code>MMCapabilityStatus</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) enum GeofencingCapabilityStatus currentCapabilityStatus;)
+ (enum GeofencingCapabilityStatus)currentCapabilityStatus SWIFT_WARN_UNUSED_RESULT;
/// Requests permission to use location services whenever the app is running.
/// \param usage Defines the usage type for which permissions is requested.
///
/// \param completion A block that will be triggered once the authorization request is finished and the capability statys is defined. The current capability status is passed to the block as a parameter.
///
- (void)authorizeWithUsage:(enum LocationServiceUsage)usage completion:(void (^ _Nonnull)(enum GeofencingCapabilityStatus))completion;
/// Starts the Geofencing Service
/// During the startup process, the service automatically asks user to grant the appropriate permissions
/// Once the user granted the permissions, the service succesfully lauches.
/// \param completion A block that will be triggered once the startup process is finished. Contains a Bool flag parameter, that indicates whether the startup succeded.
///
- (void)start:(void (^ _Nullable)(BOOL))completion;
/// Stops the Geofencing Service
- (void)stop:(void (^ _Nullable)(BOOL))completion;
/// Accepts a geo message, which contains regions that should be monitored.
/// \param message A message object to add to the monitoring. Object of <code>MMGeoMessage</code> class.
///
- (void)addWithMessage:(MMGeoMessage * _Nonnull)message completion:(void (^ _Nullable)(void))completion;
/// Removes a message from the monitoring.
- (void)removeMessageWithId:(NSString * _Nonnull)messageId;
/// The geo event handling object defines the behaviour that is triggered during the geo event.
/// You can implement your own geo event handling either by subclassing <code>MMDefaultGeoEventHandling</code> or implementing the <code>GeoEventHandling</code> protocol.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <GeoEventHandling> _Nullable geoEventsHandler;)
+ (id <GeoEventHandling> _Nullable)geoEventsHandler SWIFT_WARN_UNUSED_RESULT;
+ (void)setGeoEventsHandler:(id <GeoEventHandling> _Nullable)value;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end



@class CLLocationManager;
@class CLRegion;

@interface GeofencingService (SWIFT_EXTENSION(MobileMessaging)) <CLLocationManagerDelegate>
- (void)locationManager:(CLLocationManager * _Nonnull)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didStartMonitoringForRegion:(CLRegion * _Nonnull)region;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didEnterRegion:(CLRegion * _Nonnull)region;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didFailWithError:(NSError * _Nonnull)error;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateLocations:(NSArray<CLLocation *> * _Nonnull)locations;
@end




/// A subclass of <code>Operation</code> that executes zero or more operations as part of its
/// own execution. This class of operation is very useful for abstracting several
/// smaller operations into a larger operation. As an example, the <code>GetEarthquakesOperation</code>
/// is composed of both a <code>DownloadEarthquakesOperation</code> and a <code>ParseEarthquakesOperation</code>.
/// Additionally, <code>GroupOperation</code>s are useful if you establish a chain of dependencies,
/// but part of the chain may “loop”. For example, if you have an operation that
/// requires the user to be authenticated, you may consider putting the “login”
/// operation inside a group operation. That way, the “login” operation may produce
/// subsequent operations (still within the outer <code>GroupOperation</code>) that will all
/// be executed before the rest of the operations in the initial chain of operations.
SWIFT_CLASS("_TtC15MobileMessaging14GroupOperation")
@interface GroupOperation : Operation
- (void)cancel;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class OperationQueue;

/// The delegate of an <code>OperationQueue</code> can respond to <code>Operation</code> lifecycle
/// events by implementing these methods.
/// In general, implementing <code>OperationQueueDelegate</code> is not necessary; you would
/// want to use an <code>OperationObserver</code> instead. However, there are a couple of
/// situations where using <code>OperationQueueDelegate</code> can lead to simpler code.
/// For example, <code>GroupOperation</code> is the delegate of its own internal
/// <code>OperationQueue</code> and uses it to manage dependencies.
SWIFT_PROTOCOL("_TtP15MobileMessaging22OperationQueueDelegate_")
@protocol OperationQueueDelegate <NSObject>
@optional
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue willAddOperation:(NSOperation * _Nonnull)operation;
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue operationDidFinish:(NSOperation * _Nonnull)operation withErrors:(NSArray<NSError *> * _Nonnull)errors;
@end


@interface GroupOperation (SWIFT_EXTENSION(MobileMessaging)) <OperationQueueDelegate>
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue willAddOperation:(NSOperation * _Nonnull)operation;
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue operationDidFinish:(NSOperation * _Nonnull)operation withErrors:(NSArray<NSError *> * _Nonnull)errors;
@end


SWIFT_CLASS("_TtC15MobileMessaging31InteractiveMessageAlertSettings")
@interface InteractiveMessageAlertSettings : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Describes the kind of location service. Possible values:
/// <ul>
///   <li>
///     Location Updates
///   </li>
///   <li>
///     Region Monitoring
///   </li>
/// </ul>
SWIFT_CLASS("_TtC15MobileMessaging19LocationServiceKind")
@interface LocationServiceKind : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<LocationServiceKind *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(LocationServiceKind * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) LocationServiceKind * _Nonnull locationUpdates;)
+ (LocationServiceKind * _Nonnull)locationUpdates SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) LocationServiceKind * _Nonnull regionMonitoring;)
+ (LocationServiceKind * _Nonnull)regionMonitoring SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

/// Describes the usage type for the location service. Possible values:
/// <ul>
///   <li>
///     When in Use
///   </li>
///   <li>
///     Always
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, LocationServiceUsage, closed) {
/// This app is authorized to start most location services while running in the foreground.
  LocationServiceUsageWhenInUse = 0,
/// This app is authorized to start location services at any time.
  LocationServiceUsageAlways = 1,
};

typedef SWIFT_ENUM(NSInteger, LogoutStatus, closed) {
  LogoutStatusUndefined = 0,
  LogoutStatusPending = 1,
};

typedef SWIFT_ENUM(int8_t, MMDay, closed) {
  MMDayMo = 1,
  MMDayTu = 2,
  MMDayWe = 3,
  MMDayTh = 4,
  MMDayFr = 5,
  MMDaySa = 6,
  MMDaySu = 7,
};

@class Query;

SWIFT_PROTOCOL("_TtP15MobileMessaging22MessageStorageRemovers_")
@protocol MessageStorageRemovers
- (void)removeAllMessagesWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)removeWithIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)removeWithQuery:(Query * _Nonnull)query completion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
@end


SWIFT_PROTOCOL("_TtP15MobileMessaging21MessageStorageFinders_")
@protocol MessageStorageFinders
@property (nonatomic, copy) void (^ _Nullable messagesCountersUpdateHandler)(NSInteger, NSInteger);
- (void)countAllMessagesWithCompletion:(void (^ _Nonnull)(NSInteger))completion;
- (void)findAllMessagesWithCompletion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
- (void)findAllMessageIdsWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)findMessagesWithIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
- (void)findMessagesWithQuery:(Query * _Nonnull)query completion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
@end

enum MMSeenStatus : int16_t;
enum MOMessageSentStatus : int16_t;

/// The protocol describes implementation of the Message Storage. The Message Storage persists all the messages (both mobile originated and mobile terminated).
SWIFT_PROTOCOL("_TtP15MobileMessaging14MessageStorage_")
@protocol MessageStorage
/// The queue in which all the hooks(inserts, updates) are dispatched.
/// The queue must be provided by the particular implementation of this protocol in order to provide thread safety and performance aspects.
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull queue;
/// This method is called by the Mobile Messaging SDK during the initialization process. You implement your custom preparation routine here if needed.
- (void)start;
/// This method is called by the Mobile Messaging SDK while stopping the currently running session (see also <code>MobileMessaging.stop()</code> method). You implement your custom deinitialization routine here if needed.
- (void)stop;
/// This method is called whenever a new mobile originated message is about to be sent to the server.
- (void)insertWithOutgoing:(NSArray<BaseMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
/// This method is called whenever a new mobile terminated message (either push(remote) notifictaion or fetched message) is received by the Mobile Messaging SDK.
- (void)insertWithIncoming:(NSArray<BaseMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
/// This method is used by the Mobile Messaging SDK in order to detect duplicated messages persisted in the Message Storage. It is strongly recommended to implement this method in your custom Message Storage.
/// \param messageId unique identifier of a MT message. Consider this identifier as a primary key.
///
- (BaseMessage * _Nullable)findMessageWithId:(NSString * _Nonnull)messageId SWIFT_WARN_UNUSED_RESULT;
/// This method is called whenever the seen status is updated for a particular mobile terminated (MT) message.
/// \param status actual seen status for a message
///
/// \param messageId unique identifier of a MT message
///
- (void)updateWithMessageSeenStatus:(enum MMSeenStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
/// This method is called whenever the delivery report is updated for a particular mobile terminated (MT) message.
/// \param isDelivered boolean flag which defines whether the delivery report for a message was successfully sent
///
/// \param messageId unique identifier of a MT message
///
- (void)updateWithDeliveryReportStatus:(BOOL)isDelivered for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
/// This method is called whenever the sending status is updated for a particular mobile originated (MO) message.
/// \param status actual sending status for a MO message
///
/// \param messageId unique identifier of a MO message
///
- (void)updateWithMessageSentStatus:(enum MOMessageSentStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
/// This method is used to fetch and return all stored chat messages ids.
/// \param completion a block to be executed after fetching is completed, all the fetched message ids must be passed as a block parameter
///
- (void)findAllMessageIdsWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
@end


/// Default implementation of the Message Storage protocol. Uses Core Data persistent storage with SQLite database.
SWIFT_CLASS("_TtC15MobileMessaging23MMDefaultMessageStorage")
@interface MMDefaultMessageStorage : NSObject <MessageStorage, MessageStorageFinders, MessageStorageRemovers>
@property (nonatomic, copy) void (^ _Nullable messagesCountersUpdateHandler)(NSInteger, NSInteger);
- (void)countAllMessagesWithCompletion:(void (^ _Nonnull)(NSInteger))completion;
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull queue;
- (void)start;
- (void)stop;
- (void)findAllMessageIdsWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)insertWithOutgoing:(NSArray<BaseMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
- (void)insertWithIncoming:(NSArray<BaseMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
- (BaseMessage * _Nullable)findMessageWithId:(NSString * _Nonnull)messageId SWIFT_WARN_UNUSED_RESULT;
- (void)updateWithMessageSentStatus:(enum MOMessageSentStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
- (void)updateWithMessageSeenStatus:(enum MMSeenStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
- (void)updateWithDeliveryReportStatus:(BOOL)isDelivered for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
- (void)findAllMessagesWithCompletion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
- (void)findMessagesWithIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
- (void)findMessagesWithQuery:(Query * _Nonnull)query completion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
- (void)removeAllMessagesWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)removeWithIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)removeWithQuery:(Query * _Nonnull)query completion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging20MMDefaultChatStorage")
@interface MMDefaultChatStorage : MMDefaultMessageStorage
@end

@class MMLogOutput;
enum MMLogLevel : NSUInteger;

SWIFT_PROTOCOL("_TtP15MobileMessaging9MMLogging_")
@protocol MMLogging
@property (nonatomic, strong) MMLogOutput * _Nonnull logOutput;
@property (nonatomic) enum MMLogLevel logLevel;
@property (nonatomic, readonly, copy) NSString * _Nullable logFilePath;
- (void)sendLogsFromViewController:(UIViewController * _Nonnull)vc;
- (void)logDebugWithMessage:(NSString * _Nonnull)message;
- (void)logInfoWithMessage:(NSString * _Nonnull)message;
- (void)logErrorWithMessage:(NSString * _Nonnull)message;
- (void)logWarnWithMessage:(NSString * _Nonnull)message;
- (void)logVerboseWithMessage:(NSString * _Nonnull)message;
@end


SWIFT_CLASS("_TtC15MobileMessaging15MMDefaultLogger")
@interface MMDefaultLogger : NSObject <MMLogging>
@property (nonatomic, strong) MMLogOutput * _Nonnull logOutput;
@property (nonatomic) enum MMLogLevel logLevel;
@property (nonatomic, copy) NSString * _Nullable logFilePath;
- (void)sendLogsFromViewController:(UIViewController * _Nonnull)vc;
- (void)logDebugWithMessage:(NSString * _Nonnull)message;
- (void)logInfoWithMessage:(NSString * _Nonnull)message;
- (void)logErrorWithMessage:(NSString * _Nonnull)message;
- (void)logWarnWithMessage:(NSString * _Nonnull)message;
- (void)logVerboseWithMessage:(NSString * _Nonnull)message;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@class NotificationAction;

SWIFT_CLASS("_TtC15MobileMessaging9MTMessage")
@interface MTMessage : BaseMessage
@property (nonatomic, strong) NotificationAction * _Nullable appliedAction;
@property (nonatomic) NSTimeInterval sendDateTime;
@property (nonatomic) enum MMSeenStatus seenStatus;
@property (nonatomic, copy) NSDate * _Nullable seenDate;
@property (nonatomic) BOOL isDeliveryReportSent;
@property (nonatomic, copy) NSDate * _Nullable deliveryReportedDate;
@property (nonatomic, readonly, copy) NSString * _Nullable title;
@property (nonatomic, readonly, copy) NSString * _Nullable title_loc_key;
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable title_loc_args;
@property (nonatomic, readonly, copy) NSString * _Nullable loc_key;
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable loc_args;
@property (nonatomic, readonly, copy) NSString * _Nullable sound;
@property (nonatomic, readonly, copy) NSString * _Nullable category;
@property (nonatomic, readonly) BOOL isSilent;
@property (nonatomic, readonly, copy) NSString * _Nullable contentUrl;
@property (nonatomic, readonly) BOOL showInApp;
@property (nonatomic, readonly) BOOL isGeoSignalingMessage;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable silentData;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable internalData;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable customPayload;
@property (nonatomic, copy) NSString * _Nullable text;
/// Designated init
- (nullable instancetype)initWithPayload:(NSDictionary * _Nonnull)payload deliveryMethod:(enum MessageDeliveryMethod)deliveryMethod seenDate:(NSDate * _Nullable)seenDate deliveryReportDate:(NSDate * _Nullable)deliveryReportDate seenStatus:(enum MMSeenStatus)seenStatus isDeliveryReportSent:(BOOL)isDeliveryReportSent OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithMessageId:(NSString * _Nonnull)messageId direction:(enum MessageDirection)direction originalPayload:(NSDictionary<NSString *, id> * _Nonnull)originalPayload deliveryMethod:(enum MessageDeliveryMethod)deliveryMethod SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC15MobileMessaging12MMGeoMessage")
@interface MMGeoMessage : MTMessage
@property (nonatomic, readonly, copy) NSString * _Nonnull campaignId;
@property (nonatomic, readonly, copy) NSSet<MMRegion *> * _Nonnull regions;
@property (nonatomic, readonly, copy) NSDate * _Nonnull startTime;
@property (nonatomic, readonly, copy) NSDate * _Nonnull expiryTime;
@property (nonatomic, readonly) BOOL isNotExpired;
@property (nonatomic) enum CampaignState campaignState;
- (nullable instancetype)initWithPayload:(NSDictionary * _Nonnull)payload deliveryMethod:(enum MessageDeliveryMethod)deliveryMethod seenDate:(NSDate * _Nullable)seenDate deliveryReportDate:(NSDate * _Nullable)deliveryReportDate seenStatus:(enum MMSeenStatus)seenStatus isDeliveryReportSent:(BOOL)isDeliveryReportSent OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) BOOL isNowAppropriateTimeForEntryNotification;
@property (nonatomic, readonly) BOOL isNowAppropriateTimeForExitNotification;
@end


SWIFT_CLASS("_TtC15MobileMessaging14MMInstallation")
@interface MMInstallation : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// A read-only opaque identifier assigned by APNs to a specific app on a specific device. Each app instance receives its unique token when it registers with APNs and must share this token with its provider.
@property (nonatomic, readonly, copy) NSString * _Nullable deviceToken;
/// Explicitly tries to sync the entire installation (registration data, system data, user data) with the server.
- (void)syncInstallationWithServerWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Explicitly tries to sync the system data with the server.
- (void)syncSystemDataWithServerWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Syncs current primary device setting with the server
/// Single user profile on Infobip Portal can have one or more mobile devices with the application installed. You might want to mark one of such devices as a primary device and send push messages only to this device (i.e. receive bank authorization codes only on one device).
/// If the value was changed on device, it trumps the server value, otherwise the servers value win.
/// \param completion called after the setting is finished sync with the server
///
- (void)syncPrimarySettingWithServer:(void (^ _Nullable)(BOOL, NSError * _Nullable))completion;
/// The number currently set as the badge of the app icon in Springboard.
/// Set to 0 (zero) to hide the badge number. The default value of this property is 0.
@property (nonatomic) NSInteger badgeNumber;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSUInteger, MMLogLevel, closed) {
/// <ul>
///   <li>
///     No logs
///   </li>
/// </ul>
  MMLogLevelOff = 0,
/// <ul>
///   <li>
///     Error logs only
///   </li>
/// </ul>
  MMLogLevelError = 1,
/// <ul>
///   <li>
///     Error and warning logs
///   </li>
/// </ul>
  MMLogLevelWarning = 2,
/// <ul>
///   <li>
///     Error, warning and info logs
///   </li>
/// </ul>
  MMLogLevelInfo = 3,
/// <ul>
///   <li>
///     Error, warning, info and debug logs
///   </li>
/// </ul>
  MMLogLevelDebug = 4,
/// <ul>
///   <li>
///     Error, warning, info, debug and verbose logs
///   </li>
/// </ul>
  MMLogLevelVerbose = 5,
  MMLogLevelAll = 6,
};


SWIFT_CLASS("_TtC15MobileMessaging11MMLogOutput")
@interface MMLogOutput : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<MMLogOutput *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(MMLogOutput * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull None;)
+ (MMLogOutput * _Nonnull)None SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull Console;)
+ (MMLogOutput * _Nonnull)Console SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull ASL;)
+ (MMLogOutput * _Nonnull)ASL SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull File;)
+ (MMLogOutput * _Nonnull)File SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


@class CLCircularRegion;

SWIFT_CLASS("_TtC15MobileMessaging8MMRegion")
@interface MMRegion : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
@property (nonatomic, readonly) CLLocationCoordinate2D center;
@property (nonatomic, readonly) double radius;
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
@property (nonatomic, readonly, strong) CLCircularRegion * _Nonnull circularRegion;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull dictionaryRepresentation;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(int16_t, MMSeenStatus, closed) {
  MMSeenStatusNotSeen = 0,
  MMSeenStatusSeenNotSent = 1,
  MMSeenStatusSeenSent = 2,
};


SWIFT_CLASS("_TtC15MobileMessaging6MMUser")
@interface MMUser : NSObject
@property (nonatomic, readonly) BOOL isChanged;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Unique push registration identifier issued by server. This identifier matches one to one with APNS cloud token of the particular application installation. This identifier is only available after <code>MMNotificationRegistrationUpdated</code> event.
@property (nonatomic, readonly, copy) NSString * _Nullable pushRegistrationId;
/// Returns user’s custom data. Arbitrary attributes that are related to a particular user. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSDictionary<NSString *, CustomUserDataValue *> * _Nullable customData;
/// Saves the user’s custom data on the server asynchronously and executes the given callback block.
/// \param customData The dictionary representing data you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithCustomData:(NSDictionary<NSString *, CustomUserDataValue *> * _Nonnull)customData completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Returns the custom data value associated with a given key.
/// \param key The key for which to return the corresponding value.
///
- (CustomUserDataValue * _Nullable)customDataForKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Sets the custom data value for a given key. To save data, call <code>save(completion:)</code> method of <code>MMUser</code> object.
/// \param key The key for <code>object</code>.
///
/// \param object The object for <code>key</code>. Pass <code>object</code> as either <code>nil</code> or <code>NSNull()</code> in order to remove the key-value pair on the server.
///
- (void)setWithCustomData:(CustomUserDataValue * _Nullable)object forKey:(NSString * _Nonnull)key;
/// Sets the custom data value for a given key, immediately sends changes to the server asynchronously and executes the given callback block.
/// \param key The key for <code>object</code>.
///
/// \param object The object for <code>key</code>. Pass <code>object</code> as either <code>nil</code> or <code>NSNull()</code> in order to remove the key-value pair on the server.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithCustomData:(CustomUserDataValue * _Nullable)object forKey:(NSString * _Nonnull)key completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// The user’s id you can provide in order to link your own unique user identifier with Mobile Messaging user id, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable externalId;
/// Saves the External User Id on the server asynchronously and executes the given callback block.
/// \param externalId The id you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithExternalId:(NSString * _Nullable)externalId completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// The user’s email address. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable email;
/// Saves the email on the server asynchronously and executes the given callback block.
/// \param email The email you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithEmail:(NSString * _Nullable)email completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// A user’s MSISDN. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable msisdn;
/// Saves the MSISDN on the server asynchronously and executes the given callback block.
/// \param msisdn The MSISDN you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithMsisdn:(NSString * _Nullable)msisdn completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// The user’s first name. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable firstName;
/// Saves the first name on the server asynchronously and executes the given callback block.
/// \param firstName The first name you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithFirstName:(NSString * _Nullable)firstName completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// A user’s last name. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable lastName;
/// Saves the last name on the server asynchronously and executes the given callback block.
/// \param lastName The last name you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithLastName:(NSString * _Nullable)lastName completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// A user’s middle name. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable middleName;
/// Saves the middle name on the server asynchronously and executes the given callback block.
/// \param middleName The middle name you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithMiddleName:(NSString * _Nullable)middleName completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// A user’s birthdate. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSDate * _Nullable birthdate;
/// Saves the birthdate on the server asynchronously and executes the given callback block.
/// \param birthdate The birthdate you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithBirthdate:(NSDate * _Nullable)birthdate completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Explicitly tries to save all user data on the server.
/// \param completion The block to execute after the server responded.
///
- (void)save:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Tries to fetch the user data from the server.
/// \param completion The block to execute after the server responded.
///
- (void)fetchFromServerWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end



typedef SWIFT_ENUM(NSInteger, MMUserPredefinedDataKeys, closed) {
  MMUserPredefinedDataKeysMSISDN = 0,
  MMUserPredefinedDataKeysFirstName = 1,
  MMUserPredefinedDataKeysLastName = 2,
  MMUserPredefinedDataKeysMiddleName = 3,
  MMUserPredefinedDataKeysGender = 4,
  MMUserPredefinedDataKeysBirthdate = 5,
  MMUserPredefinedDataKeysEmail = 6,
};


SWIFT_CLASS("_TtC15MobileMessaging9MOMessage")
@interface MOMessage : BaseMessage
@property (nonatomic, copy) NSString * _Nullable destination;
@property (nonatomic) enum MOMessageSentStatus sentStatus;
@property (nonatomic, copy) NSDate * _Nonnull composedDate;
@property (nonatomic, copy) NSString * _Nullable bulkId;
@property (nonatomic, copy) NSString * _Nullable initialMessageId;
- (nonnull instancetype)initWithDestination:(NSString * _Nullable)destination text:(NSString * _Nonnull)text customPayload:(NSDictionary<NSString *, id <CustomPayloadSupportedTypes>> * _Nullable)customPayload composedDate:(NSDate * _Nonnull)composedDate bulkId:(NSString * _Nullable)bulkId initialMessageId:(NSString * _Nullable)initialMessageId;
- (nonnull instancetype)initWithMessageId:(NSString * _Nonnull)messageId direction:(enum MessageDirection)direction originalPayload:(NSDictionary<NSString *, id> * _Nonnull)originalPayload deliveryMethod:(enum MessageDeliveryMethod)deliveryMethod SWIFT_UNAVAILABLE;
@end

typedef SWIFT_ENUM(int16_t, MOMessageSentStatus, closed) {
  MOMessageSentStatusUndefined = -1,
  MOMessageSentStatusSentSuccessfully = 0,
  MOMessageSentStatusSentWithFailure = 1,
};








@class NSEntityDescription;
@class NSManagedObjectContext;

SWIFT_CLASS("_TtC15MobileMessaging7Message")
@interface Message : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end





typedef SWIFT_ENUM(int16_t, MessageDeliveryMethod, closed) {
  MessageDeliveryMethodUndefined = 0,
  MessageDeliveryMethodPush = 1,
  MessageDeliveryMethodPull = 2,
  MessageDeliveryMethodGeneratedLocally = 3,
  MessageDeliveryMethodLocal = 4,
};

typedef SWIFT_ENUM(int16_t, MessageDirection, closed) {
  MessageDirectionMT = 0,
  MessageDirectionMO = 1,
};

@class UNNotification;
@class UserNotificationType;

SWIFT_PROTOCOL("_TtP15MobileMessaging23MessageHandlingDelegate_")
@protocol MessageHandlingDelegate
@optional
/// Called when a new message is received.
/// \param message the new message received
///
- (void)didReceiveNewMessageWithMessage:(MTMessage * _Nonnull)message;
/// Called when a notification is delivered to a foreground app.
/// If your app is in the foreground when a notification arrives, the MobileMessaging SDK calls this method to deliver the notification directly to your app. If you implement this method, you can take whatever actions are necessary to process the notification and update your app. When you finish, execute the completionHandler block and specify how you want the system to alert the user, if at all.
- (void)willPresentInForegroundWithMessage:(MTMessage * _Nullable)message notification:(UNNotification * _Nonnull)notification withCompletionHandler:(void (^ _Nonnull)(UserNotificationType * _Nonnull))completionHandler SWIFT_AVAILABILITY(ios,introduced=10.0);
/// Called when a notification is delivered to a foreground app.
- (void)didReceiveNewMessageInForegroundWithMessage:(MTMessage * _Nonnull)message SWIFT_AVAILABILITY(ios,deprecated=10.0,message="Use willPresentInForeground(message:withCompletionHandler:)");
/// Called when a local notification scheduled for a message. Apart from push messages that are pushed to the device by APNs and displayed by iOS automatically, MobileMessaging SDK delivers messages by pulling them from the server and generating them locally. These messages are displayed via Local Notifications.
- (void)willScheduleLocalNotificationFor:(MTMessage * _Nonnull)message;
@required
/// Called when a notification action is performed by the user.
/// \param action <code>NotificationAction</code> object defining the action which was triggered.
///
/// \param message <code>MTMessage</code> message, for which action button was displayed, you can use <code>message.categoryId</code> in order to check the categoryId for action.
///
/// \param notificationUserInfo a dictionary representing original local/remote notification’s userInfo
///
/// \param completion The block to execute when specified action performing is finished. <em>You must call this block either immediately or after your handling is completed.</em> The block is originally passed to AppDelegate’s <code>application(_:handleActionWithIdentifier:forRemoteNotification:completionHandler:)</code> callback as a <code>completionHandler</code> parameter.
///
- (void)didPerformWithAction:(NotificationAction * _Nonnull)action forMessage:(MTMessage * _Nullable)message notificationUserInfo:(NSDictionary<NSString *, id> * _Nullable)notificationUserInfo completion:(void (^ _Nonnull)(void))completion;
@end



SWIFT_PROTOCOL("_TtP15MobileMessaging22MessageStorageDelegate_")
@protocol MessageStorageDelegate
- (void)didInsertNewMessages:(NSArray<BaseMessage *> * _Nonnull)messages;
- (void)didUpdateMessage:(BaseMessage * _Nonnull)message;
- (void)didRemoveMessages:(NSArray<BaseMessage *> * _Nonnull)messages;
@end




SWIFT_CLASS("_TtC15MobileMessaging10MobileChat")
@interface MobileChat : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_PROTOCOL("_TtP15MobileMessaging18MobileChatProtocol_")
@protocol MobileChatProtocol
/// Sends message with a specified text to a particular chat id.
/// \param chatId id of destination chat
///
/// \param text body of the message
///
/// \param completion a block to be executed when sending is finished
///
- (void)sendWithChatId:(NSString * _Nullable)chatId text:(NSString * _Nonnull)text completion:(void (^ _Nullable)(ChatMessage * _Nullable, NSError * _Nullable))completion;
/// Sends message with a specified text to a particular chat id.
/// \param chatId id of destination chat
///
/// \param text body of the message
///
/// \param customPayload additional data to send along with the chat message
///
/// \param completion a block to be executed when sending is finished. Contains a sent message object and an error
///
- (void)sendWithChatId:(NSString * _Nullable)chatId text:(NSString * _Nonnull)text customPayload:(NSDictionary<NSString *, id <CustomPayloadSupportedTypes>> * _Nonnull)customPayload completion:(void (^ _Nullable)(ChatMessage * _Nullable, NSError * _Nullable))completion;
/// Sets user info for curren chat user.
/// \param info object representing chat user data
///
/// \param completion a block to be executed when operation is finished. Contains an error object
///
- (void)setUserInfoWithInfo:(ChatParticipant * _Nonnull)info completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Returns chat users profile cached locally.
///
/// returns:
/// <code>ChatParticipant</code> object representing chat user data
- (ChatParticipant * _Nullable)getUserInfo SWIFT_WARN_UNUSED_RESULT;
/// Returns chat users profile from the server.
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     completion: a block to be executed when operation is finished. Contains the fetched chat user data
///   </li>
/// </ul>
- (void)fetchUserInfoWithCompletion:(void (^ _Nullable)(ChatParticipant * _Nullable))completion;
/// Returns the default chat messsage storage if used. For more information see <code>MMDefaultMessageStorage</code> class description.
@property (nonatomic, readonly, strong) MMDefaultChatStorage * _Nullable defaultChatStorage;
/// Marks all messages as seen
- (void)markAllMessagesSeenWithCompletion:(void (^ _Nullable)(void))completion;
/// Marks specific messages as seen
- (void)markMessagesSeenWithMessageIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nullable)(void))completion;
/// A wrapper around NSFetchedResultsController set up to manage the results of a Core Data fetch request applied to chat message storage. Only available for default chat message storage (returns <code>nil</code> otherwise).
@property (nonatomic, readonly, strong) ChatMessagesController * _Nullable chatMessagesController;
@end


@interface MobileChat (SWIFT_EXTENSION(MobileMessaging)) <MobileChatProtocol>
- (void)markMessagesSeenWithMessageIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nullable)(void))completion;
- (void)markAllMessagesSeenWithCompletion:(void (^ _Nullable)(void))completion;
@property (nonatomic, readonly, strong) ChatMessagesController * _Nullable chatMessagesController;
@property (nonatomic, readonly, strong) MMDefaultChatStorage * _Nullable defaultChatStorage;
- (void)sendWithChatId:(NSString * _Nullable)chatId text:(NSString * _Nonnull)text completion:(void (^ _Nullable)(ChatMessage * _Nullable, NSError * _Nullable))completion;
- (void)sendWithChatId:(NSString * _Nullable)chatId text:(NSString * _Nonnull)text customPayload:(NSDictionary<NSString *, id <CustomPayloadSupportedTypes>> * _Nonnull)customPayload completion:(void (^ _Nullable)(ChatMessage * _Nullable, NSError * _Nullable))completion;
- (void)setUserInfoWithInfo:(ChatParticipant * _Nonnull)info completion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (ChatParticipant * _Nullable)getUserInfo SWIFT_WARN_UNUSED_RESULT;
- (void)fetchUserInfoWithCompletion:(void (^ _Nullable)(ChatParticipant * _Nullable))completion;
@end


@class UILocalNotification;
@class UserAgent;
@class NSURLSessionConfiguration;
@class PrivacySettings;

SWIFT_CLASS("_TtC15MobileMessaging15MobileMessaging")
@interface MobileMessaging : NSObject
/// Fabric method for Mobile Messaging session.
/// \param code The application code of your Application from Push Portal website.
///
/// \param notificationType Preferable notification types that indicating how the app alerts the user when a push notification arrives.
///
+ (MobileMessaging * _Nullable)withApplicationCode:(NSString * _Nonnull)code notificationType:(UserNotificationType * _Nonnull)notificationType SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// warning:
/// The cleanup (parameter <code>forceCleanup = true</code>) must be performed manually if you changed the application code while <code>PrivacySettings.applicationCodePersistingDisabled</code> is set to <code>true</code>.
/// \param code The application code of your Application from Push Portal website.
///
/// \param notificationType Preferable notification types that indicating how the app alerts the user when a push notification arrives.
///
/// \param forceCleanup Defines whether the SDK must be cleaned up on startup.
///
+ (MobileMessaging * _Nullable)withApplicationCode:(NSString * _Nonnull)code notificationType:(UserNotificationType * _Nonnull)notificationType forceCleanup:(BOOL)forceCleanup SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// \param notificationType Preferable notification types that indicating how the app alerts the user when a push notification arrives.
///
/// \param code The application code of your Application from Push Portal website.
///
/// \param backendBaseURL Your backend server base URL, optional parameter. Default is https://oneapi.infobip.com.
///
+ (MobileMessaging * _Nullable)withApplicationCode:(NSString * _Nonnull)code notificationType:(UserNotificationType * _Nonnull)notificationType backendBaseURL:(NSString * _Nonnull)backendBaseURL SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// It is possible to supply a default implementation of Message Storage to the Mobile Messaging library during initialization. In this case the library will save all received Push messages using the <code>MMDefaultMessageStorage</code>. Library can also be initialized either without message storage or with user-provided one (see <code>withMessageStorage(messageStorage:)</code>).
- (MobileMessaging * _Nonnull)withDefaultMessageStorage SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// It is possible to supply an implementation of Message Storage to the Mobile Messaging library during initialization. In this case the library will save all received Push messages to the supplied <code>messageStorage</code>. Library can also be initialized either without message storage or with the default message storage (see <code>withDefaultMessageStorage()</code> method).
/// \param messageStorage a storage object, that implements the <code>MessageStorage</code> protocol
///
- (MobileMessaging * _Nonnull)withMessageStorage:(id <MessageStorage> _Nonnull)messageStorage SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// It is possible to postpone the registration for Push Notifications. It is up to you to define when and where the user will be promt to allow receiving Push Notifications. By default the registration is being performed by <code>MobileMessaging.start()</code> call.
/// remark:
/// Don’t forget to register for Push Notifications explicitly by calling <code>MobileMessaging.registerForRemoteNotifications()</code>.
- (MobileMessaging * _Nonnull)withoutRegisteringForRemoteNotifications SWIFT_WARN_UNUSED_RESULT;
/// Starts a new Mobile Messaging session.
/// This method should be called form AppDelegate’s <code>application(_:didFinishLaunchingWithOptions:)</code> callback.
/// remark:
/// For now, Mobile Messaging SDK doesn’t support Badge. You should handle the badge counter by yourself.
- (void)start:(void (^ _Nullable)(void))completion;
/// Syncronizes all available subservices with the server.
+ (void)sync;
/// Sets primary device setting
/// Single user profile on Infobip Portal can have one or more mobile devices with the application installed. You might want to mark one of such devices as a primary device and send push messages only to this device (i.e. receive bank authorization codes only on one device).
/// \param isPrimary defines whether to set current device as primery one or not
///
/// \param completion called after the setting is finished sync with the server
///
+ (void)setAsPrimaryDevice:(BOOL)isPrimary completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Synchronizes primary device setting with server
+ (void)syncPrimaryDeviceWithCompletion:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completion;
/// Primary device setting
/// Single user profile on Infobip Portal can have one or more mobile devices with the application installed. You might want to mark one of such devices as a primary device and send push messages only to this device (i.e. receive bank authorization codes only on one device).
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL isPrimaryDevice;)
+ (BOOL)isPrimaryDevice SWIFT_WARN_UNUSED_RESULT;
+ (void)setIsPrimaryDevice:(BOOL)newValue;
/// Current push registration status.
/// The status defines whether the device is allowed to be receiving push notifications (regular push messages/geofencing campaign messages/messages fetched from the server).
/// MobileMessaging SDK has the push registration enabled by default.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isPushRegistrationEnabled;)
+ (BOOL)isPushRegistrationEnabled SWIFT_WARN_UNUSED_RESULT;
/// Cleans up all internal persisted data.
/// Use this method in order to completely drop any data persisted by the SDK (i.e. internal SDK data, optional user data, optional messages metadata).
/// \param clearKeychain defines whether the internalId in keychain will be cleaned. True by default.
///
+ (void)cleanUpAndStop:(BOOL)clearKeychain;
/// Enables the push registration so the device can receive push notifications (regular push messages/geofencing campaign messages/messages fetched from the server).
/// MobileMessaging SDK has the push registration enabled by default.
+ (void)enablePushRegistrationWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Disables the push registration so the device no longer receives any push notifications (regular push messages/geofencing campaign messages/messages fetched from the server).
/// MobileMessaging SDK has the push registration enabled by default.
+ (void)disablePushRegistrationWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Stops all the currently running Mobile Messaging services.
/// attention:
/// This function doesn’t disable push notifications, they are still being received by the OS.
/// \param cleanUpData defines whether the Mobile Messaging internal storage will be dropped. False by default.
///
+ (void)stop:(BOOL)cleanUpData;
/// Call this method to initiate the registration process with Apple Push Notification service. User will be promt to allow receiving Push Notifications.
+ (void)registerForRemoteNotifications;
/// Logging utility is used for:
/// <ul>
///   <li>
///     setting up the logging options and logging levels.
///   </li>
///   <li>
///     obtaining a path to the logs file in case the Logging utility is set up to log in file (logging options contains <code>.file</code> option).
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <MMLogging> _Nullable logger;)
+ (id <MMLogging> _Nullable)logger SWIFT_WARN_UNUSED_RESULT;
+ (void)setLogger:(id <MMLogging> _Nullable)value;
/// This method handles a new APNs device token and updates user’s registration on the server.
/// This method should be called form AppDelegate’s <code>application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</code> callback.
/// \param token A token that identifies a particular device to APNs.
///
+ (void)didRegisterForRemoteNotificationsWithDeviceToken:(NSData * _Nonnull)token;
/// This method handles incoming remote notifications and triggers sending procedure for delivery reports. The method should be called from AppDelegate’s <code>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</code> callback.
/// \param userInfo A dictionary that contains information related to the remote notification, potentially including a badge number for the app icon, an alert sound, an alert message to display to the user, a notification identifier, and custom data.
///
/// \param completionHandler A block to execute when the download operation is complete. The block is originally passed to AppDelegate’s <code>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</code> callback as a <code>fetchCompletionHandler</code> parameter. Mobile Messaging will execute this block after sending notification’s delivery report.
///
+ (void)didReceiveRemoteNotification:(NSDictionary * _Nonnull)userInfo fetchCompletionHandler:(void (^ _Nonnull)(UIBackgroundFetchResult))completionHandler;
/// This method is called when a running app receives a local notification. The method should be called from AppDelegate’s <code>application(_:didReceiveLocalNotification:)</code> or <code>application(_:didReceive:)</code> callback.
/// \param notification A local notification that encapsulates details about the notification, potentially including custom data.
///
/// \param completion A block to be executed when local notification handling is finished
///
+ (void)didReceiveLocalNotification:(UILocalNotification * _Nonnull)notification completion:(void (^ _Nullable)(void))completion SWIFT_AVAILABILITY(ios,deprecated=10.0);
/// Maintains attributes related to the current application installation such as APNs device token, badge number, etc.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMInstallation * _Nullable currentInstallation;)
+ (MMInstallation * _Nullable)currentInstallation SWIFT_WARN_UNUSED_RESULT;
/// Returns the default message storage if used. For more information see <code>MMDefaultMessageStorage</code> class description.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMDefaultMessageStorage * _Nullable defaultMessageStorage;)
+ (MMDefaultMessageStorage * _Nullable)defaultMessageStorage SWIFT_WARN_UNUSED_RESULT;
/// Maintains attributes related to the current user such as unique ID for the registered user, email, MSISDN, custom data, external id.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMUser * _Nullable currentUser;)
+ (MMUser * _Nullable)currentUser SWIFT_WARN_UNUSED_RESULT;
/// This method sets seen status for messages and sends a corresponding request to the server. If something went wrong, the library will repeat the request until it reaches the server.
/// \param messageIds Array of identifiers of messages that need to be marked as seen.
///
+ (void)setSeenWithMessageIds:(NSArray<NSString *> * _Nonnull)messageIds;
/// This method sends mobile originated messages to the server.
/// \param messages Array of objects of <code>MOMessage</code> class that need to be sent.
///
/// \param completion The block to execute after the server responded, passes an array of <code>MOMessage</code> messages, that cont
///
+ (void)sendMessages:(NSArray<MOMessage *> * _Nonnull)messages completion:(void (^ _Nullable)(NSArray<MOMessage *> * _Nullable, NSError * _Nullable))completion;
/// An auxillary component provides the convinient access to the user agent data.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserAgent * _Nonnull userAgent;)
+ (UserAgent * _Nonnull)userAgent SWIFT_WARN_UNUSED_RESULT;
/// The <code>MessageHandlingDelegate</code> protocol defines methods for responding to actionable notifications and receiving new notifications. You assign your delegate object to the <code>messageHandlingDelegate</code> property of the <code>MobileMessaging</code> class. The MobileMessaging SDK calls methods of your delegate at appropriate times to deliver information.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <MessageHandlingDelegate> _Nullable messageHandlingDelegate;)
+ (id <MessageHandlingDelegate> _Nullable)messageHandlingDelegate SWIFT_WARN_UNUSED_RESULT;
+ (void)setMessageHandlingDelegate:(id <MessageHandlingDelegate> _Nullable)value;
/// The <code>URLSessionConfiguration</code> used for all url connections in the SDK
/// Default value is <code>URLSessionConfiguration.default</code>.
/// You can provide your own configuration to define a custom NSURLProtocol, policies etc.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) NSURLSessionConfiguration * _Nonnull urlSessionConfiguration;)
+ (NSURLSessionConfiguration * _Nonnull)urlSessionConfiguration SWIFT_WARN_UNUSED_RESULT;
+ (void)setUrlSessionConfiguration:(NSURLSessionConfiguration * _Nonnull)value;
/// The <code>PrivacySettings</code> class incapsulates privacy settings that affect the SDK behaviour and business logic.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) PrivacySettings * _Nonnull privacySettings;)
+ (PrivacySettings * _Nonnull)privacySettings SWIFT_WARN_UNUSED_RESULT;
/// Erases currently stored UserData associated with push registration along with messages in SDK storage.
/// User’s data synced over MobileMessaging is by default associated with created push registration. Logging out user means that push registration and device specific data will remain, but user’s data (such as first name, custom data, …) will be wiped out.
/// If you log out user, there is no mechanism to log him in again since he’s already subscribed for broadcast notifications from your app, but you might want to sync new user data to target this user specifically.
/// remark:
/// There is another version of logout method that doesn’t require a <code>completion</code> parameter which means the SDK will handle any unsuccessful logout request by itself. See the method documentation for more details. Use this method in following cases:
/// <ul>
///   <li>
///     you want to handle possible failures of server logout request and retry and maintain pending logout state by yourself
///   </li>
///   <li>
///     you’re syncing user data to our server;
///   </li>
///   <li>
///     your application has logout option;
///   </li>
///   <li>
///     you don’t want new logged in user to be targeted by other user’s data, e.g. first name;
///   </li>
///   <li>
///     you want logged out user to still receive broadcast notifications (if not, you need to call MobileMessaging.disablePushRegistration()).
///   </li>
/// </ul>
/// \param completion The block to execute after the logout procedure finished
///
+ (void)logoutWithCompletion:(void (^ _Nonnull)(enum LogoutStatus, NSError * _Nullable))completion;
/// Erases currently stored UserData associated with push registration along with messages in SDK storage.
/// User’s data synced over MobileMessaging is by default associated with created push registration. Logging out user means that push registration and device specific data will remain, but user’s data (such as first name, custom data, …) will be wiped out.
/// If you log out user, there is no mechanism to log him in again since he’s already subscribed for broadcast notifications from your app, but you might want to sync new user data to target this user specifically.
/// remark:
/// There is another version of logout method that doesn’t require a <code>completion</code> parameter which means the SDK will handle any unsuccessful logout request by itself. See the method documentation for more details. Use this method in following cases:
/// <ul>
///   <li>
///     you don’t need to hanlde networking failures and maintain pending logout state by yourself
///   </li>
///   <li>
///     you’re syncing user data to our server;
///   </li>
///   <li>
///     your application has logout option;
///   </li>
///   <li>
///     you don’t want new logged in user to be targeted by other user’s data, e.g. first name;
///   </li>
///   <li>
///     you want logged out user to still receive broadcast notifications (if not, you need to call MobileMessaging.disablePushRegistration()).
///   </li>
/// </ul>
+ (void)logout;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
/// Fabric method for Mobile Messaging session.
/// App Groups used to share data among app Notification Extension and the main application itself. Provide the appropriate App Group ID for both application and application extension in order to keep them in sync.
/// remark:
/// If you are facing with the following error in your console:
/// <code>[User Defaults] Failed to read values in CFPrefsPlistSource<0xXXXXXXX> (Domain: ..., User: kCFPreferencesAnyUser, ByHost: Yes, Container: (null)): Using kCFPreferencesAnyUser with a container is only allowed for SystemContainers, detaching from cfprefsd</code>.
/// Although this warning doesn’t mean that our code doesn’t work, you can shut it up by prefixing your App Group ID with a Team ID of a certificate that you are signing the build with. For example: <code>"9S95Y6XXXX.group.com.mobile-messaging.notification-service-extension"</code>. The App Group ID itself doesn’t need to be changed though.
/// \param appGroupId An ID of an App Group
///
- (MobileMessaging * _Nonnull)withAppGroupId:(NSString * _Nonnull)appGroupId SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("The function is deprecated. Please put your App Group Id as a String value for a key `com.mobilemessaging.app_group` in your main info dictionary (Info.plist by defautlt).");
@end


@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
/// This service manages geofencing areas, emits geografical regions entering/exiting notifications.
/// You access the Geofencing service APIs through this property.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GeofencingService * _Nullable geofencingService;)
+ (GeofencingService * _Nullable)geofencingService SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// Use this method to enable the Geofencing service.
- (MobileMessaging * _Nonnull)withGeofencingService SWIFT_WARN_UNUSED_RESULT;
@end

@class NotificationCategory;

@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
/// Fabric method for Mobile Messaging session.
/// remark:
/// Mobile Messaging SDK reserves category Ids and action Ids with “mm_” prefix. Custom actions and categories with this prefix will be discarded.
/// \param categories Set of categories to define which buttons to display and their behavour.
///
- (MobileMessaging * _Nonnull)withInteractiveNotificationCategories:(NSSet<NotificationCategory *> * _Nonnull)categories SWIFT_WARN_UNUSED_RESULT;
/// This method handles interactive notifications actions and performs work that is defined for this action. The method should be called from AppDelegate’s <code>application(_:handleActionWithIdentifier:for:withResponseInfo:completionHandler:)</code> callback.
/// \param identifier The identifier for the interactive notification action.
///
/// \param localNotification The local notification object that was triggered.
///
/// \param responseInfo The data dictionary sent by the action. Potentially could contain text entered by the user in response to the text input action.
///
/// \param completionHandler A block that you must call when you are finished performing the action. It is originally passed to AppDelegate’s <code>application(_:handleActionWithIdentifier:for:withResponseInfo:completionHandler:)</code> callback as a <code>completionHandler</code> parameter.
///
+ (void)handleActionWithIdentifierWithIdentifier:(NSString * _Nullable)identifier localNotification:(UILocalNotification * _Nonnull)localNotification responseInfo:(NSDictionary * _Nullable)responseInfo completionHandler:(void (^ _Nonnull)(void))completionHandler SWIFT_AVAILABILITY(ios,deprecated=10.0);
/// This method handles interactive notifications actions and performs work that is defined for this action. The method should be called from AppDelegate’s <code>application(_:handleActionWithIdentifier:forRemoteNotification:withResponseInfo:completionHandler:)</code> callback.
/// \param identifier The identifier for the interactive notification action.
///
/// \param userInfo A dictionary that contains information related to the remote notification. This dictionary originates from the provider as a JSON-defined dictionary, which iOS converts to an NSDictionary object before calling this method. The contents of the dictionary are the remote notification payload, which consists only of property-list objects plus NSNull
///
/// \param responseInfo The data dictionary sent by the action. Potentially could contain text entered by the user in response to the text input action.
///
/// \param completionHandler A block that you must call when you are finished performing the action. It is originally passed to AppDelegate’s <code>application(_:handleActionWithIdentifier:forRemoteNotification:withResponseInfo:completionHandler:)</code> callback as a <code>completionHandler</code> parameter.
///
+ (void)handleActionWithIdentifierWithIdentifier:(NSString * _Nullable)identifier forRemoteNotification:(NSDictionary * _Nonnull)userInfo responseInfo:(NSDictionary * _Nullable)responseInfo completionHandler:(void (^ _Nonnull)(void))completionHandler;
/// Returns <code>NotificationCategory</code> object for provided category Id. Category Id can be obtained from <code>MTMessage</code> object with <code>MTMessage.category</code> method.
/// \param identifier The identifier associated with the category of interactive notification
///
+ (NotificationCategory * _Nullable)categoryWithId:(NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
@end


@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
/// This service manages Mobile Chat, provides API for sending and receiving mobile chat messages.
/// You access the Mobile Chat service APIs through this property.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MobileChat * _Nullable mobileChat;)
+ (MobileChat * _Nullable)mobileChat SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// Use this method to enable the Mobile Chat service with default message storage implementation.
- (MobileMessaging * _Nonnull)withMobileChat SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// Use this method to enable the Mobile Chat service with a your custom message storage implementation.
- (MobileMessaging * _Nonnull)withMobileChatWithStorage:(id <MessageStorage> _Nonnull)storage SWIFT_WARN_UNUSED_RESULT;
@end

@class UNNotificationRequest;
@class UNNotificationContent;

SWIFT_CLASS("_TtC15MobileMessaging43MobileMessagingNotificationServiceExtension") SWIFT_AVAILABILITY(ios,introduced=10.0)
@interface MobileMessagingNotificationServiceExtension : NSObject
/// Starts a new Mobile Messaging Notification Service Extension session.
/// This method should be called form <code>didReceive(_:, withContentHandler:)</code> of your subclass of UNNotificationServiceExtension.
/// remark:
/// If you are facing with the following error in your console:
/// <code>[User Defaults] Failed to read values in CFPrefsPlistSource<0xXXXXXXX> (Domain: ..., User: kCFPreferencesAnyUser, ByHost: Yes, Container: (null)): Using kCFPreferencesAnyUser with a container is only allowed for SystemContainers, detaching from cfprefsd</code>.
/// Although this warning doesn’t mean that our code doesn’t work, you can shut it up by prefixing your App Group ID with a Team ID of a certificate that you are signing the build with. For example: <code>"9S95Y6XXXX.group.com.mobile-messaging.notification-service-extension"</code>. The App Group ID itself doesn’t need to be changed though.
/// \param code The application code of your Application from Push Portal website.
///
/// \param appGroupId An ID of an App Group. App Groups used to share data among app Notification Extension and the main application itself. Provide the appropriate App Group ID for both application and application extension in order to keep them in sync.
///
+ (void)startWithApplicationCode:(NSString * _Nonnull)code appGroupId:(NSString * _Nonnull)appGroupId SWIFT_DEPRECATED_MSG("The function is deprecated. Plese use `MobileMessagingNotificationServiceExtension.start()` instead and put your Application Code and App Group Id as String values for keys `com.mobilemessaging.app_code` and `com.mobilemessaging.app_group` respectively in your main info dictionary (info .plist file).");
/// Starts a new Mobile Messaging Notification Service Extension session.
/// This method should be called form <code>didReceive(_:, withContentHandler:)</code> of your subclass of UNNotificationServiceExtension.
/// <em>It is required for the session start to put your Application Code and App Group Id as String values for keys</em> <code>com.mobilemessaging.app_code</code> <em>and</em> <code>com.mobilemessaging.app_group</code> <em>respectively in your main info dictionary (info .plist file)</em>
/// remark:
/// If you are facing with the following error in your console:
/// <code>[User Defaults] Failed to read values in CFPrefsPlistSource<0xXXXXXXX> (Domain: ..., User: kCFPreferencesAnyUser, ByHost: Yes, Container: (null)): Using kCFPreferencesAnyUser with a container is only allowed for SystemContainers, detaching from cfprefsd</code>.
/// Although this warning doesn’t mean that our code doesn’t work, you can shut it up by prefixing your App Group ID with a Team ID of a certificate that you are signing the build with. For example: <code>"9S95Y6XXXX.group.com.mobile-messaging.notification-service-extension"</code>. The App Group ID itself doesn’t need to be changed though.
+ (void)start;
/// This method handles an incoming notification on the Notification Service Extensions side. It performs message delivery reporting and downloads data from <code>contentUrl</code> if provided. This method must be called within <code>UNNotificationServiceExtension.didReceive(_: withContentHandler:)</code> callback.
/// \param request The original notification request. Use this object to get the original content of the notification.
///
/// \param contentHandler The block to execute with the modified content. The block will be called after the delivery reporting and contend downloading finished.
///
+ (void)didReceive:(UNNotificationRequest * _Nonnull)request withContentHandler:(void (^ _Nonnull)(UNNotificationContent * _Nonnull))contentHandler;
+ (void)serviceExtensionTimeWillExpire;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_PROTOCOL("_TtP15MobileMessaging23UserDataFoundationTypes_")
@protocol UserDataFoundationTypes
@end


@interface NSDate (SWIFT_EXTENSION(MobileMessaging)) <UserDataFoundationTypes>
@end




@interface NSError (SWIFT_EXTENSION(MobileMessaging))
@property (nonatomic, readonly, copy) NSString * _Nullable mm_message;
@property (nonatomic, readonly, copy) NSString * _Nullable mm_code;
@end












@interface NSNull (SWIFT_EXTENSION(MobileMessaging)) <CustomPayloadSupportedTypes>
@end


@interface NSNull (SWIFT_EXTENSION(MobileMessaging)) <UserDataFoundationTypes>
@end


@interface NSNumber (SWIFT_EXTENSION(MobileMessaging)) <CustomPayloadSupportedTypes>
@end


@interface NSNumber (SWIFT_EXTENSION(MobileMessaging)) <UserDataFoundationTypes>
@end






@interface NSString (SWIFT_EXTENSION(MobileMessaging)) <CustomPayloadSupportedTypes>
@end


@interface NSString (SWIFT_EXTENSION(MobileMessaging)) <UserDataFoundationTypes>
@end

@class NotificationActionOptions;

SWIFT_CLASS("_TtC15MobileMessaging18NotificationAction")
@interface NotificationAction : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull DismissActionId;)
+ (NSString * _Nonnull)DismissActionId SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull DefaultActionId;)
+ (NSString * _Nonnull)DefaultActionId SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
@property (nonatomic, readonly, copy) NSArray<NotificationActionOptions *> * _Nonnull options;
@property (nonatomic, readonly) BOOL isTapOnNotificationAlert;
/// Initializes the <code>NotificationAction</code>
/// \param identifier action identifier. “mm_” prefix is reserved for Mobile Messaging ids and cannot be used as a prefix.
///
/// \param title Title of the button which will be displayed.
///
/// \param options Options with which to perform the action.
///
- (nullable instancetype)initWithIdentifier:(NSString * _Nonnull)identifier title:(NSString * _Nonnull)title options:(NSArray<NotificationActionOptions *> * _Nullable)options;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging25NotificationActionOptions")
@interface NotificationActionOptions : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<NotificationActionOptions *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(MMLogOutput * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
/// Causes the launch of the application.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationActionOptions * _Nonnull foreground;)
+ (NotificationActionOptions * _Nonnull)foreground SWIFT_WARN_UNUSED_RESULT;
/// Marks the action button as destructive.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationActionOptions * _Nonnull destructive;)
+ (NotificationActionOptions * _Nonnull)destructive SWIFT_WARN_UNUSED_RESULT;
/// Requires the device to be unlocked.
/// remark:
/// If the action options contains <code>.foreground</code>, then the action is considered as requiring authentication automatically.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationActionOptions * _Nonnull authenticationRequired;)
+ (NotificationActionOptions * _Nonnull)authenticationRequired SWIFT_WARN_UNUSED_RESULT;
/// Indicates whether the SDK must generate MO message to report on users interaction.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationActionOptions * _Nonnull moRequired;)
+ (NotificationActionOptions * _Nonnull)moRequired SWIFT_WARN_UNUSED_RESULT;
/// Indicates whether action is compatible with chat messages. If it is compatible, the action button will be shown in the SDK buil-in chat view.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationActionOptions * _Nonnull chatCompatible;)
+ (NotificationActionOptions * _Nonnull)chatCompatible SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class NotificationCategoryOptions;

SWIFT_CLASS("_TtC15MobileMessaging20NotificationCategory")
@interface NotificationCategory : NSObject
/// The category identifier passed in a <code>MTMessage</code> object
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// Actions in the order to be displayed for available contexts.
/// remark:
/// If there are more than four action objects in the array, the notification displays only the first four. When displaying banner notifications, the system displays only the first two actions.
@property (nonatomic, readonly, copy) NSArray<NotificationAction *> * _Nonnull actions;
/// Options indicating how to handle notifications associated with category.
@property (nonatomic, readonly, copy) NSArray<NotificationCategoryOptions *> * _Nonnull options;
/// The intent identifier strings, which defined in Intents framework, that you want to associate with notifications of this category.
/// remark:
/// Intent identifier may be useful for SiriKit support.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull intentIdentifiers;
/// Initializes the <code>NotificationCategory</code>
/// \param identifier category identifier. “mm_” prefix is reserved for Mobile Messaging ids and cannot be used as a prefix.
///
/// \param actions Actions in the order to be displayed for available contexts.
///
/// \param options Options indicating how to handle notifications associated with category. Supported only for iOS 10+.
///
/// \param intentIdentifiers The intent identifier strings, which defined in Intents framework, that you want to associate with notifications of this category. Supported only for iOS 10+.
///
- (nullable instancetype)initWithIdentifier:(NSString * _Nonnull)identifier actions:(NSArray<NotificationAction *> * _Nonnull)actions options:(NSArray<NotificationCategoryOptions *> * _Nullable)options intentIdentifiers:(NSArray<NSString *> * _Nullable)intentIdentifiers OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithDictionary:(NSDictionary<NSString *, id> * _Nonnull)dictionary OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end




SWIFT_CLASS("_TtC15MobileMessaging27NotificationCategoryOptions")
@interface NotificationCategoryOptions : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<NotificationCategoryOptions *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(NotificationCategoryOptions * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
/// remark:
/// This option is available only for iOS 10+
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationCategoryOptions * _Nonnull allowInCarPlay SWIFT_AVAILABILITY(ios,introduced=10.0);)
+ (NotificationCategoryOptions * _Nonnull)allowInCarPlay SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end







/// <code>OperationQueue</code> is an <code>NSOperationQueue</code> subclass that implements a large
/// number of “extra features” related to the <code>Operation</code> class:
/// <ul>
///   <li>
///     Notifying a delegate of all operation completion
///   </li>
///   <li>
///     Extracting generated dependencies from operation conditions
///   </li>
///   <li>
///     Setting up dependencies to enforce mutual exclusivity
///   </li>
/// </ul>
SWIFT_CLASS("_TtC15MobileMessaging14OperationQueue")
@interface OperationQueue : NSOperationQueue
- (void)addOperation:(NSOperation * _Nonnull)operation;
- (void)addOperations:(NSArray<NSOperation *> * _Nonnull)ops waitUntilFinished:(BOOL)wait;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// The <code>PrivacySettings</code> class incapsulates privacy settings that affect the SDK behaviour and business logic.
SWIFT_CLASS("_TtC15MobileMessaging15PrivacySettings")
@interface PrivacySettings : NSObject
/// A boolean variable that indicates whether the MobileMessaging SDK will be sending the carrier information to the server.
/// Default value is <code>false</code>.
@property (nonatomic) BOOL carrierInfoSendingDisabled;
/// A boolean variable that indicates whether the MobileMessaging SDK will be sending the system information such as OS version, device model, application version to the server.
/// Default value is <code>false</code>.
@property (nonatomic) BOOL systemInfoSendingDisabled;
/// A boolean variable that indicates whether the MobileMessaging SDK will be persisting the application code locally. This feature is a convenience to maintain SDK viability during debugging and possible application code changes.
/// Default value is <code>false</code>.
/// warning:
/// there might be situation when you want to switch between different Application Codes during development/testing. If you disable the application code persisting (value <code>true</code>), the SDK won’t detect the application code changes, thus won’t cleanup the old application code related data. You should manually invoke <code>MobileMessaging.cleanUpAndStop()</code> prior to start otherwise the SDK would not detect the application code change.
@property (nonatomic) BOOL applicationCodePersistingDisabled;
/// A boolean variable that indicates whether the MobileMessaging SDK will be persisting the user data locally. Persisting user data locally gives you quick access to the data and eliminates a need to implement it yourself.
/// Default value is <code>false</code>.
@property (nonatomic) BOOL userDataPersistingDisabled;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSPredicate;
@class NSSortDescriptor;

/// The class defines a query that is used to fetch messages from the Message Storage.
SWIFT_CLASS("_TtC15MobileMessaging5Query")
@interface Query : NSObject
/// note:
///
/// The following types of predicates are supported:
/// <ul>
///   <li>
///     Simple comparisons such as <code>=</code>, <code>!=</code>, <code><</code>, <code>></code>, <code><=</code>, <code>>=</code>, and <code>BETWEEN</code> with a key and a constant.
///   </li>
///   <li>
///     Containment predicates, such as <code>x IN {1, 2, 3}</code>.
///   </li>
///   <li>
///     Key-existence predicates, such as <code>x IN SELF</code>.
///   </li>
///   <li>
///     <code>BEGINSWITH</code> expressions.
///   </li>
///   <li>
///     Compound predicates with <code>AND</code>, <code>OR</code>, and <code>NOT</code>.
///   </li>
///   <li>
///     SubQueries with key IN %@, subquery.
///   </li>
/// </ul>
/// The following types of predicates are NOT supported:
/// <ul>
///   <li>
///     Aggregate operations, such as <code>ANY</code>, <code>SOME</code>, <code>ALL</code>, or <code>NONE</code>.
///   </li>
///   <li>
///     Regular expressions, such as <code>LIKE</code>, <code>MATCHES</code>, <code>CONTAINS</code>, or <code>ENDSWITH</code>.
///   </li>
///   <li>
///     Predicates comparing one key to another.
///   </li>
///   <li>
///     Complex predicates with many ORed clauses.
///   </li>
/// </ul>
@property (nonatomic, strong) NSPredicate * _Nullable predicate;
/// An array of <code>NSSortDescriptor</code> objects to use to sort the results of the query.
@property (nonatomic, copy) NSArray<NSSortDescriptor *> * _Nullable sortDescriptors;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Allows text input from the user
SWIFT_CLASS("_TtC15MobileMessaging27TextInputNotificationAction") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface TextInputNotificationAction : NotificationAction
@property (nonatomic, readonly, copy) NSString * _Nonnull textInputActionButtonTitle;
@property (nonatomic, readonly, copy) NSString * _Nonnull textInputPlaceholder;
/// Text which was entered in response to action.
@property (nonatomic, copy) NSString * _Nullable typedText;
/// Initializes the <code>TextInputNotificationAction</code>
/// \param identifier action identifier. “mm_” prefix is reserved for Mobile Messaging ids and cannot be used as a prefix.
///
/// \param title Title of the button which will be displayed.
///
/// \param options Options with which to perform the action.
///
/// \param textInputActionButtonTitle Title of the text input action button
///
/// \param textInputPlaceholder Placeholder in the text input field.
///
- (nullable instancetype)initWithIdentifier:(NSString * _Nonnull)identifier title:(NSString * _Nonnull)title options:(NSArray<NotificationActionOptions *> * _Nullable)options textInputActionButtonTitle:(NSString * _Nonnull)textInputActionButtonTitle textInputPlaceholder:(NSString * _Nonnull)textInputPlaceholder OBJC_DESIGNATED_INITIALIZER;
@end












@interface UIDevice (SWIFT_EXTENSION(MobileMessaging))
@property (nonatomic, readonly) BOOL IS_IOS_BEFORE_10;
@end






















SWIFT_CLASS("_TtC15MobileMessaging9UserAgent")
@interface UserAgent : NSObject
@property (nonatomic, copy) NSString * _Nullable cordovaPluginVersion;
@property (nonatomic, readonly) BOOL notificationsEnabled;
@property (nonatomic, readonly, copy) NSString * _Nonnull currentUserAgentString;
@property (nonatomic, readonly, copy) NSString * _Nonnull osVersion;
@property (nonatomic, readonly, copy) NSString * _Nonnull osName;
@property (nonatomic, readonly, copy) NSString * _Nonnull libraryVersion;
@property (nonatomic, readonly, copy) NSString * _Nonnull libraryName;
@property (nonatomic, readonly, copy) NSString * _Nonnull hostingAppVersion;
@property (nonatomic, readonly, copy) NSString * _Nonnull hostingAppName;
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceManufacturer;
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceName;
@property (nonatomic, readonly) BOOL deviceSecure;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end




typedef SWIFT_ENUM(NSInteger, UserGender, closed) {
  UserGenderFemale = 0,
  UserGenderMale = 1,
};


SWIFT_CLASS("_TtC15MobileMessaging20UserNotificationType")
@interface UserNotificationType : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<UserNotificationType *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(UserNotificationType * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserNotificationType * _Nonnull none;)
+ (UserNotificationType * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
/// The ability to display alerts.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserNotificationType * _Nonnull alert;)
+ (UserNotificationType * _Nonnull)alert SWIFT_WARN_UNUSED_RESULT;
/// The ability to update the app’s badge.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserNotificationType * _Nonnull badge;)
+ (UserNotificationType * _Nonnull)badge SWIFT_WARN_UNUSED_RESULT;
/// The ability to play sounds.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserNotificationType * _Nonnull sound;)
+ (UserNotificationType * _Nonnull)sound SWIFT_WARN_UNUSED_RESULT;
/// The ability to display notifications in a CarPlay environment.
/// remark:
/// This option is available only for iOS 10+
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserNotificationType * _Nonnull carPlay SWIFT_AVAILABILITY(ios,introduced=10.0);)
+ (UserNotificationType * _Nonnull)carPlay SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
